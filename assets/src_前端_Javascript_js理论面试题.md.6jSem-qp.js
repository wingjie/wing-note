import{_ as i,c as l,o as a,ag as o}from"./chunks/framework.Dpoz9nJ7.js";const u=JSON.parse('{"title":"js理论面试题","description":"","frontmatter":{},"headers":[],"relativePath":"src/前端/Javascript/js理论面试题.md","filePath":"src/前端/Javascript/js理论面试题.md","lastUpdated":1710326451000}'),r={name:"src/前端/Javascript/js理论面试题.md"};function t(c,e,p,s,d,n){return a(),l("div",null,[...e[0]||(e[0]=[o('<h1 id="js理论面试题" tabindex="-1">js理论面试题 <a class="header-anchor" href="#js理论面试题" aria-label="Permalink to &quot;js理论面试题&quot;">​</a></h1><h2 id="从url输入到页面展现到底发生了什么" tabindex="-1">从url输入到页面展现到底发生了什么 <a class="header-anchor" href="#从url输入到页面展现到底发生了什么" aria-label="Permalink to &quot;从url输入到页面展现到底发生了什么&quot;">​</a></h2><ul><li>DNS解析，将域名解析成ip地址</li><li>TCP连接，TCP三次握手</li><li>浏览器发送HTTP请求</li><li>服务器处理请求并返回HTTP报文</li><li>浏览器解析渲染页面 <ol><li>解析HTML，构建DOM树</li><li>解析CSS，生成CSS规则树</li><li>合并DOM树和CSS规则，生成render树</li><li>布局render树（Layout/reflow），负责各元素尺寸、位置的计算</li><li>绘制render树（paint），绘制页面像素信息</li></ol></li><li>断开连接，TCP四次挥手；</li></ul><h2 id="tcp三次握手的过程" tabindex="-1">TCP三次握手的过程 <a class="header-anchor" href="#tcp三次握手的过程" aria-label="Permalink to &quot;TCP三次握手的过程&quot;">​</a></h2><p>TCP握手协议</p><p>在TCP/IP协议中,TCP协议提供可靠的连接服务,采用三次握手建立一个连接.</p><p>第一次握手：建立连接时,客户端发送syn包(syn=j)到服务器,并进入SYN_SEND状态,等待服务器确认；</p><p>SYN：同步序列编号(Synchronize Sequence Numbers)</p><p>第二次握手：服务器收到syn包,必须确认客户的SYN（ack=j+1）,同时自己也发送一个SYN包（syn=k）,即SYN+ACK包,此时服务器进入SYN_RECV状态；</p><p>第三次握手：客户端收到服务器的SYN＋ACK包,向服务器发送确认包ACK(ack=k+1),此包发送完毕,客户端和服务器进入ESTABLISHED状态,完成三次握手.</p><p>三次握手的步骤：（抽象派）</p><p>客户端：hello，你是server么？</p><p>服务端：hello，我是server，你是client么</p><p>客户端：yes，我是client</p><p>四次挥手的步骤：（抽象派）</p><p>主动方：我已经关闭了向你那边的主动通道了，只能被动接收了</p><p>被动方：收到通道关闭的信息</p><p>被动方：那我也告诉你，我这边向你的主动通道也关闭了</p><p>主动方：最后收到数据，之后双方无法通信</p><h2 id="缓存" tabindex="-1">缓存 <a class="header-anchor" href="#缓存" aria-label="Permalink to &quot;缓存&quot;">​</a></h2><h3 id="强制缓存" tabindex="-1"><strong>强制缓存</strong> <a class="header-anchor" href="#强制缓存" aria-label="Permalink to &quot;**强制缓存**&quot;">​</a></h3><p>强制缓存是指客户端请求后，会先访问缓存数据库看缓存是否存在，如果存在直接返回，不存在则请求真的服务器，响应后再存入数据库；可以造成强制缓存的字段是cache-control和expires；</p><ul><li>expires 是表示缓存到期时间，是绝对的时间（当前时间+缓存时间），http1.0的字段； <ol><li>expires由于是绝对时间，用户可以随意更改本地时间，达到缓存失效，或者由于时差的原因，也会导致失效；</li><li>expires写法比较复杂，字符串多个空格或少个字母都会导致失效</li></ol></li><li>cache-control 是http1.1中增加的字段，表示资源缓存的最大有效时间，在该时间内，客户端不需要向服务器发送请求；cache-control是相对时间；cache-control常用的值： <ol><li>max-age：最大有效时间，单位s</li><li>must-revalidate：</li><li>no-cache：需要使用对比缓存来验证缓存数据</li><li>no-store：真正意义上的不要缓存，所有内容都不走缓存，包括强制和协商；</li><li>public：所有的内容都可以被缓存（包括客户端和代理服务器，如CDN）；</li><li>private：所有的内容只有客户端才可以缓存，代理服务器不能缓存。默认值；</li></ol></li></ul><p>一般设置：<code>cache-control:public,max-age=1000</code></p><h3 id="协商缓存" tabindex="-1"><strong>协商缓存</strong> <a class="header-anchor" href="#协商缓存" aria-label="Permalink to &quot;**协商缓存**&quot;">​</a></h3><p>浏览器先请求缓存数据库，返回一个缓存标识。之后浏览器拿这个标识和服务器通讯。如果缓存未失效，则返回 HTTP 状态码 304 表示继续使用，于是客户端继续使用缓存；如果失效，则返回新的数据和缓存规则，浏览器响应数据后，再把规则写入到缓存数据库。</p><p>协商缓存主要涉及两组header字段：Etag和if-none-match，last-modified和if-modified-since</p><p><strong><code>Last-Modify</code>和<code>if-modified-since</code></strong></p><p>浏览器第一次请求一个资源的时候，服务器返回的header中会加上<code>Last-Modify</code>，<code>Last-Modify</code>是一个时间标识该资源的最后修改时间，例如<code>Last-Modify: Thu,31 Dec 2037 23:59:59 GMT</code>。</p><p>当浏览器再次请求该资源时，request的请求头中会包含 <code>if-modified-since</code>，该值为缓存之前返回的<code>Last-Modify</code>。服务器收到<code>if-modified-since</code>后，根据资源的最后修改时间判断是否使用缓存。</p><p>如果使用缓存，则返回304，<strong>并且不会返回资源内容，并且不会返回Last-Modify。</strong></p><p><strong><code>Etag</code>和<code>If-None-Match</code></strong></p><p><code>Etag</code>/<code>If-None-Match</code>存储的是文件唯一标识（一般是hash生成的），ETag可以保证每一个资源是唯一的，资源变化都会导致ETag变化。服务器根据浏览器上的<code>If-None-Match</code>值来判断是否命中缓存 。服务器同样进行比较，命中返回 304, 不命中返回新资源和 200。</p><p>Etag的优先级要高于last-modify</p><h3 id="缓存的位置" tabindex="-1"><strong>缓存的位置</strong> <a class="header-anchor" href="#缓存的位置" aria-label="Permalink to &quot;**缓存的位置**&quot;">​</a></h3><ul><li>memory cache 内存中的缓存，首先查找内存之后再查找硬盘，关闭浏览器或tab时存储到硬盘里面</li><li>disk cache 硬盘缓存，会严格根据http头信息中的各类字段来判断哪些资源可以缓存，读取速度虽然比memory cache慢但是比网络请求快</li><li>service worker 与上述两种不同，前端可以自己使用service worker，通过f12 ==》 application ==》 cache storage查找到，这个缓存是永久性的，关闭tab或浏览器下次打开依然存在，只有手动调用<code>cache.delete(resource)</code>或者容量超过限制才被清空</li></ul><p>缓存查找的优先级（由上到下查找）：</p><ol><li>service workder</li><li>memory cache</li><li>disk cache</li><li>网络请求</li></ol><p>浏览器发起请求时：</p><p><img src="http://notecdn.hrhe.cn/images/%E7%BC%93%E5%AD%98%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AF%B7%E6%B1%82.png" alt="image"></p><p>浏览器再次请求时：</p><p><img src="http://notecdn.hrhe.cn/images/%E7%BC%93%E5%AD%98%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%8D%E6%AC%A1%E8%AF%B7%E6%B1%82.png" alt="image">()</p><p><strong>缓存的优点</strong></p><ul><li>减少冗余的数据传输</li><li>减少服务器负担</li><li>加快客户端加载网页的速度</li></ul><p>参考文献：</p><ul><li><a href="https://juejin.cn/post/6844903747357769742" target="_blank" rel="noreferrer">一文读懂前端缓存</a></li><li><a href="https://juejin.cn/post/7083178636852854792" target="_blank" rel="noreferrer">前端面试常见的浏览器缓存（强缓存、协商缓存），代码实操</a></li></ul><h2 id="proxy与object-defineproperty的优劣对比" tabindex="-1">Proxy与Object.defineProperty的优劣对比? <a class="header-anchor" href="#proxy与object-defineproperty的优劣对比" aria-label="Permalink to &quot;Proxy与Object.defineProperty的优劣对比?&quot;">​</a></h2><p>Proxy的优势如下:</p><ul><li>Proxy可以直接监听对象而非属性</li><li>Proxy可以直接监听数组的变化</li><li>Proxy有多达13种拦截方法,不限于apply、ownKeys、deleteProperty、has等等是Object.defineProperty不具备的</li><li>Proxy返回的是一个新对象,我们可以只操作新的对象达到目的,而Object.defineProperty只能遍历对象属性直接修改</li><li>Proxy作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利</li></ul><p><code>Object.defineProperty</code>的优势如下:</p><ul><li>兼容性好,支持IE9</li></ul><h2 id="前端常见攻击方式" tabindex="-1">前端常见攻击方式 <a class="header-anchor" href="#前端常见攻击方式" aria-label="Permalink to &quot;前端常见攻击方式&quot;">​</a></h2><ul><li>XSS攻击 ---- 跨站脚本攻击，向页面中插入恶意脚本执行</li><li>CSRF攻击 --- 跨站请求伪造，冒充用户发送请求</li><li>Sql注入 ---- 在用户输入框输入sql命令进行攻击</li><li>html脚本注入</li></ul><h2 id="前端常用跨域方案" tabindex="-1">前端常用跨域方案 <a class="header-anchor" href="#前端常用跨域方案" aria-label="Permalink to &quot;前端常用跨域方案&quot;">​</a></h2><ul><li>JSONP跨域（本质是js调用）</li><li>CORS 后台配置</li><li>postMessage 两个window之间的跨域解决方案</li><li>Nginx 反向代理</li></ul><p>跨域是浏览器做出的安全限制，必须同协议、同域名、同端口否则会被浏览器block</p><h2 id="什么是virtual-dom" tabindex="-1">什么是Virtual dom <a class="header-anchor" href="#什么是virtual-dom" aria-label="Permalink to &quot;什么是Virtual dom&quot;">​</a></h2><p>用javascript对象结构表示dom树的结构；然后用这个树构建一个真正的DOM树，插到文档当中，当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树的差异，把所记录的差异应用到所构建的真正的dom树上，视图就更新了。virtual dom本质上就是在js和dom之间做了一个缓存；</p><h2 id="前端网站常规优化方案" tabindex="-1">前端网站常规优化方案 <a class="header-anchor" href="#前端网站常规优化方案" aria-label="Permalink to &quot;前端网站常规优化方案&quot;">​</a></h2><p>优化策略：减少请求次数、减小资源大小、提高响应和加载速度、优化资源加载时机、优化加载方式</p><ul><li>合并、压缩、混淆html/css/js文件（webpack实现，减小资源大小）</li><li>Nginx开启Gzip，进一步压缩资源（减小资源大小）</li><li>图片资源使用CDN加速（提高加载速度）</li><li>符合条件的图标做base64处理（减小资源大小）</li><li>样式表放首部、js放尾部（js单线程，会阻塞页面，资源加载方式）</li><li>设置缓存（强缓存和协商缓存，提高加载速度）</li><li>link或者src添加rel属性，设置prefetch或preload可预加载资源（加载时机）</li><li>如果使用了ui组件库，采用按需加载（减小资源大小）</li><li>SPA项目，通过import或者require做路由按需加载（减小资源大小）</li><li>服务端渲染SSR，加快首屏渲染，利于SEO</li><li>页面使用骨架屏，提高首页加载速度</li><li>使用JPEG 2000, JPEG XR, and WebP的图片格式来代替现有的jpeg和png，该页面图片较多时，这点作用非常明显</li><li>使用图片懒加载-lazyload</li></ul>',61)])])}const m=i(r,[["render",t]]);export{u as __pageData,m as default};
